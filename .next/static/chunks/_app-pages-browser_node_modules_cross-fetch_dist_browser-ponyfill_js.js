"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_cross-fetch_dist_browser-ponyfill_js"],{

/***/ "(app-pages-browser)/./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// Save global object in a variable\n\nvar __global__ = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g;\n// Create an object that extends from __global__ without the fetch function\nvar __globalThis__ = function() {\n    function F() {\n        this.fetch = false;\n        this.DOMException = __global__.DOMException;\n    }\n    F.prototype = __global__; // Needed for feature detection on whatwg-fetch's code\n    return new F();\n}();\n// Wraps whatwg-fetch with a function scope to hijack the global object\n// \"globalThis\" that's going to be patched\n(function(globalThis1) {\n    var irrelevant = function(exports1) {\n        var global1 = typeof globalThis1 !== \"undefined\" && globalThis1 || typeof self !== \"undefined\" && self || typeof global1 !== \"undefined\" && global1;\n        var support = {\n            searchParams: \"URLSearchParams\" in global1,\n            iterable: \"Symbol\" in global1 && \"iterator\" in Symbol,\n            blob: \"FileReader\" in global1 && \"Blob\" in global1 && function() {\n                try {\n                    new Blob();\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }(),\n            formData: \"FormData\" in global1,\n            arrayBuffer: \"ArrayBuffer\" in global1\n        };\n        function isDataView(obj) {\n            return obj && DataView.prototype.isPrototypeOf(obj);\n        }\n        if (support.arrayBuffer) {\n            var viewClasses = [\n                \"[object Int8Array]\",\n                \"[object Uint8Array]\",\n                \"[object Uint8ClampedArray]\",\n                \"[object Int16Array]\",\n                \"[object Uint16Array]\",\n                \"[object Int32Array]\",\n                \"[object Uint32Array]\",\n                \"[object Float32Array]\",\n                \"[object Float64Array]\"\n            ];\n            var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n            };\n        }\n        function normalizeName(name) {\n            if (typeof name !== \"string\") {\n                name = String(name);\n            }\n            if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n                throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n            }\n            return name.toLowerCase();\n        }\n        function normalizeValue(value) {\n            if (typeof value !== \"string\") {\n                value = String(value);\n            }\n            return value;\n        }\n        // Build a destructive iterator for the value list\n        function iteratorFor(items) {\n            var iterator = {\n                next: function() {\n                    var value = items.shift();\n                    return {\n                        done: value === undefined,\n                        value: value\n                    };\n                }\n            };\n            if (support.iterable) {\n                iterator[Symbol.iterator] = function() {\n                    return iterator;\n                };\n            }\n            return iterator;\n        }\n        function Headers(headers) {\n            this.map = {};\n            if (headers instanceof Headers) {\n                headers.forEach(function(value, name) {\n                    this.append(name, value);\n                }, this);\n            } else if (Array.isArray(headers)) {\n                headers.forEach(function(header) {\n                    this.append(header[0], header[1]);\n                }, this);\n            } else if (headers) {\n                Object.getOwnPropertyNames(headers).forEach(function(name) {\n                    this.append(name, headers[name]);\n                }, this);\n            }\n        }\n        Headers.prototype.append = function(name, value) {\n            name = normalizeName(name);\n            value = normalizeValue(value);\n            var oldValue = this.map[name];\n            this.map[name] = oldValue ? oldValue + \", \" + value : value;\n        };\n        Headers.prototype[\"delete\"] = function(name) {\n            delete this.map[normalizeName(name)];\n        };\n        Headers.prototype.get = function(name) {\n            name = normalizeName(name);\n            return this.has(name) ? this.map[name] : null;\n        };\n        Headers.prototype.has = function(name) {\n            return this.map.hasOwnProperty(normalizeName(name));\n        };\n        Headers.prototype.set = function(name, value) {\n            this.map[normalizeName(name)] = normalizeValue(value);\n        };\n        Headers.prototype.forEach = function(callback, thisArg) {\n            for(var name in this.map){\n                if (this.map.hasOwnProperty(name)) {\n                    callback.call(thisArg, this.map[name], name, this);\n                }\n            }\n        };\n        Headers.prototype.keys = function() {\n            var items = [];\n            this.forEach(function(value, name) {\n                items.push(name);\n            });\n            return iteratorFor(items);\n        };\n        Headers.prototype.values = function() {\n            var items = [];\n            this.forEach(function(value) {\n                items.push(value);\n            });\n            return iteratorFor(items);\n        };\n        Headers.prototype.entries = function() {\n            var items = [];\n            this.forEach(function(value, name) {\n                items.push([\n                    name,\n                    value\n                ]);\n            });\n            return iteratorFor(items);\n        };\n        if (support.iterable) {\n            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n        }\n        function consumed(body) {\n            if (body.bodyUsed) {\n                return Promise.reject(new TypeError(\"Already read\"));\n            }\n            body.bodyUsed = true;\n        }\n        function fileReaderReady(reader) {\n            return new Promise(function(resolve, reject) {\n                reader.onload = function() {\n                    resolve(reader.result);\n                };\n                reader.onerror = function() {\n                    reject(reader.error);\n                };\n            });\n        }\n        function readBlobAsArrayBuffer(blob) {\n            var reader = new FileReader();\n            var promise = fileReaderReady(reader);\n            reader.readAsArrayBuffer(blob);\n            return promise;\n        }\n        function readBlobAsText(blob) {\n            var reader = new FileReader();\n            var promise = fileReaderReady(reader);\n            reader.readAsText(blob);\n            return promise;\n        }\n        function readArrayBufferAsText(buf) {\n            var view = new Uint8Array(buf);\n            var chars = new Array(view.length);\n            for(var i = 0; i < view.length; i++){\n                chars[i] = String.fromCharCode(view[i]);\n            }\n            return chars.join(\"\");\n        }\n        function bufferClone(buf) {\n            if (buf.slice) {\n                return buf.slice(0);\n            } else {\n                var view = new Uint8Array(buf.byteLength);\n                view.set(new Uint8Array(buf));\n                return view.buffer;\n            }\n        }\n        function Body() {\n            this.bodyUsed = false;\n            this._initBody = function(body) {\n                /*\n        fetch-mock wraps the Response object in an ES6 Proxy to\n        provide useful test harness features such as flush. However, on\n        ES5 browsers without fetch or Proxy support pollyfills must be used;\n        the proxy-pollyfill is unable to proxy an attribute unless it exists\n        on the object before the Proxy is created. This change ensures\n        Response.bodyUsed exists on the instance, while maintaining the\n        semantic of setting Request.bodyUsed in the constructor before\n        _initBody is called.\n      */ this.bodyUsed = this.bodyUsed;\n                this._bodyInit = body;\n                if (!body) {\n                    this._bodyText = \"\";\n                } else if (typeof body === \"string\") {\n                    this._bodyText = body;\n                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n                    this._bodyBlob = body;\n                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n                    this._bodyFormData = body;\n                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                    this._bodyText = body.toString();\n                } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n                    this._bodyArrayBuffer = bufferClone(body.buffer);\n                    // IE 10-11 can't handle a DataView body.\n                    this._bodyInit = new Blob([\n                        this._bodyArrayBuffer\n                    ]);\n                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n                    this._bodyArrayBuffer = bufferClone(body);\n                } else {\n                    this._bodyText = body = Object.prototype.toString.call(body);\n                }\n                if (!this.headers.get(\"content-type\")) {\n                    if (typeof body === \"string\") {\n                        this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n                    } else if (this._bodyBlob && this._bodyBlob.type) {\n                        this.headers.set(\"content-type\", this._bodyBlob.type);\n                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                        this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n                    }\n                }\n            };\n            if (support.blob) {\n                this.blob = function() {\n                    var rejected = consumed(this);\n                    if (rejected) {\n                        return rejected;\n                    }\n                    if (this._bodyBlob) {\n                        return Promise.resolve(this._bodyBlob);\n                    } else if (this._bodyArrayBuffer) {\n                        return Promise.resolve(new Blob([\n                            this._bodyArrayBuffer\n                        ]));\n                    } else if (this._bodyFormData) {\n                        throw new Error(\"could not read FormData body as blob\");\n                    } else {\n                        return Promise.resolve(new Blob([\n                            this._bodyText\n                        ]));\n                    }\n                };\n                this.arrayBuffer = function() {\n                    if (this._bodyArrayBuffer) {\n                        var isConsumed = consumed(this);\n                        if (isConsumed) {\n                            return isConsumed;\n                        }\n                        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n                            return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));\n                        } else {\n                            return Promise.resolve(this._bodyArrayBuffer);\n                        }\n                    } else {\n                        return this.blob().then(readBlobAsArrayBuffer);\n                    }\n                };\n            }\n            this.text = function() {\n                var rejected = consumed(this);\n                if (rejected) {\n                    return rejected;\n                }\n                if (this._bodyBlob) {\n                    return readBlobAsText(this._bodyBlob);\n                } else if (this._bodyArrayBuffer) {\n                    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n                } else if (this._bodyFormData) {\n                    throw new Error(\"could not read FormData body as text\");\n                } else {\n                    return Promise.resolve(this._bodyText);\n                }\n            };\n            if (support.formData) {\n                this.formData = function() {\n                    return this.text().then(decode);\n                };\n            }\n            this.json = function() {\n                return this.text().then(JSON.parse);\n            };\n            return this;\n        }\n        // HTTP methods whose capitalization should be normalized\n        var methods = [\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"OPTIONS\",\n            \"POST\",\n            \"PUT\"\n        ];\n        function normalizeMethod(method) {\n            var upcased = method.toUpperCase();\n            return methods.indexOf(upcased) > -1 ? upcased : method;\n        }\n        function Request(input, options) {\n            if (!(this instanceof Request)) {\n                throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n            }\n            options = options || {};\n            var body = options.body;\n            if (input instanceof Request) {\n                if (input.bodyUsed) {\n                    throw new TypeError(\"Already read\");\n                }\n                this.url = input.url;\n                this.credentials = input.credentials;\n                if (!options.headers) {\n                    this.headers = new Headers(input.headers);\n                }\n                this.method = input.method;\n                this.mode = input.mode;\n                this.signal = input.signal;\n                if (!body && input._bodyInit != null) {\n                    body = input._bodyInit;\n                    input.bodyUsed = true;\n                }\n            } else {\n                this.url = String(input);\n            }\n            this.credentials = options.credentials || this.credentials || \"same-origin\";\n            if (options.headers || !this.headers) {\n                this.headers = new Headers(options.headers);\n            }\n            this.method = normalizeMethod(options.method || this.method || \"GET\");\n            this.mode = options.mode || this.mode || null;\n            this.signal = options.signal || this.signal;\n            this.referrer = null;\n            if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n                throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n            }\n            this._initBody(body);\n            if (this.method === \"GET\" || this.method === \"HEAD\") {\n                if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n                    // Search for a '_' parameter in the query string\n                    var reParamSearch = /([?&])_=[^&]*/;\n                    if (reParamSearch.test(this.url)) {\n                        // If it already exists then set the value with the current time\n                        this.url = this.url.replace(reParamSearch, \"$1_=\" + new Date().getTime());\n                    } else {\n                        // Otherwise add a new '_' parameter to the end with the current time\n                        var reQueryString = /\\?/;\n                        this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + new Date().getTime();\n                    }\n                }\n            }\n        }\n        Request.prototype.clone = function() {\n            return new Request(this, {\n                body: this._bodyInit\n            });\n        };\n        function decode(body) {\n            var form = new FormData();\n            body.trim().split(\"&\").forEach(function(bytes) {\n                if (bytes) {\n                    var split = bytes.split(\"=\");\n                    var name = split.shift().replace(/\\+/g, \" \");\n                    var value = split.join(\"=\").replace(/\\+/g, \" \");\n                    form.append(decodeURIComponent(name), decodeURIComponent(value));\n                }\n            });\n            return form;\n        }\n        function parseHeaders(rawHeaders) {\n            var headers = new Headers();\n            // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n            // https://tools.ietf.org/html/rfc7230#section-3.2\n            var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n            // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n            // https://github.com/github/fetch/issues/748\n            // https://github.com/zloirock/core-js/issues/751\n            preProcessedHeaders.split(\"\\r\").map(function(header) {\n                return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n            }).forEach(function(line) {\n                var parts = line.split(\":\");\n                var key = parts.shift().trim();\n                if (key) {\n                    var value = parts.join(\":\").trim();\n                    headers.append(key, value);\n                }\n            });\n            return headers;\n        }\n        Body.call(Request.prototype);\n        function Response(bodyInit, options) {\n            if (!(this instanceof Response)) {\n                throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n            }\n            if (!options) {\n                options = {};\n            }\n            this.type = \"default\";\n            this.status = options.status === undefined ? 200 : options.status;\n            this.ok = this.status >= 200 && this.status < 300;\n            this.statusText = options.statusText === undefined ? \"\" : \"\" + options.statusText;\n            this.headers = new Headers(options.headers);\n            this.url = options.url || \"\";\n            this._initBody(bodyInit);\n        }\n        Body.call(Response.prototype);\n        Response.prototype.clone = function() {\n            return new Response(this._bodyInit, {\n                status: this.status,\n                statusText: this.statusText,\n                headers: new Headers(this.headers),\n                url: this.url\n            });\n        };\n        Response.error = function() {\n            var response = new Response(null, {\n                status: 0,\n                statusText: \"\"\n            });\n            response.type = \"error\";\n            return response;\n        };\n        var redirectStatuses = [\n            301,\n            302,\n            303,\n            307,\n            308\n        ];\n        Response.redirect = function(url, status) {\n            if (redirectStatuses.indexOf(status) === -1) {\n                throw new RangeError(\"Invalid status code\");\n            }\n            return new Response(null, {\n                status: status,\n                headers: {\n                    location: url\n                }\n            });\n        };\n        exports1.DOMException = global1.DOMException;\n        try {\n            new exports1.DOMException();\n        } catch (err) {\n            exports1.DOMException = function(message, name) {\n                this.message = message;\n                this.name = name;\n                var error = Error(message);\n                this.stack = error.stack;\n            };\n            exports1.DOMException.prototype = Object.create(Error.prototype);\n            exports1.DOMException.prototype.constructor = exports1.DOMException;\n        }\n        function fetch(input, init) {\n            return new Promise(function(resolve, reject) {\n                var request = new Request(input, init);\n                if (request.signal && request.signal.aborted) {\n                    return reject(new exports1.DOMException(\"Aborted\", \"AbortError\"));\n                }\n                var xhr = new XMLHttpRequest();\n                function abortXhr() {\n                    xhr.abort();\n                }\n                xhr.onload = function() {\n                    var options = {\n                        status: xhr.status,\n                        statusText: xhr.statusText,\n                        headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n                    };\n                    options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n                    var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n                    setTimeout(function() {\n                        resolve(new Response(body, options));\n                    }, 0);\n                };\n                xhr.onerror = function() {\n                    setTimeout(function() {\n                        reject(new TypeError(\"Network request failed\"));\n                    }, 0);\n                };\n                xhr.ontimeout = function() {\n                    setTimeout(function() {\n                        reject(new TypeError(\"Network request failed\"));\n                    }, 0);\n                };\n                xhr.onabort = function() {\n                    setTimeout(function() {\n                        reject(new exports1.DOMException(\"Aborted\", \"AbortError\"));\n                    }, 0);\n                };\n                function fixUrl(url) {\n                    try {\n                        return url === \"\" && global1.location.href ? global1.location.href : url;\n                    } catch (e) {\n                        return url;\n                    }\n                }\n                xhr.open(request.method, fixUrl(request.url), true);\n                if (request.credentials === \"include\") {\n                    xhr.withCredentials = true;\n                } else if (request.credentials === \"omit\") {\n                    xhr.withCredentials = false;\n                }\n                if (\"responseType\" in xhr) {\n                    if (support.blob) {\n                        xhr.responseType = \"blob\";\n                    } else if (support.arrayBuffer && request.headers.get(\"Content-Type\") && request.headers.get(\"Content-Type\").indexOf(\"application/octet-stream\") !== -1) {\n                        xhr.responseType = \"arraybuffer\";\n                    }\n                }\n                if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers)) {\n                    Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n                        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n                    });\n                } else {\n                    request.headers.forEach(function(value, name) {\n                        xhr.setRequestHeader(name, value);\n                    });\n                }\n                if (request.signal) {\n                    request.signal.addEventListener(\"abort\", abortXhr);\n                    xhr.onreadystatechange = function() {\n                        // DONE (success or failure)\n                        if (xhr.readyState === 4) {\n                            request.signal.removeEventListener(\"abort\", abortXhr);\n                        }\n                    };\n                }\n                xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n            });\n        }\n        fetch.polyfill = true;\n        if (!global1.fetch) {\n            global1.fetch = fetch;\n            global1.Headers = Headers;\n            global1.Request = Request;\n            global1.Response = Response;\n        }\n        exports1.Headers = Headers;\n        exports1.Request = Request;\n        exports1.Response = Response;\n        exports1.fetch = fetch;\n        return exports1;\n    }({});\n})(__globalThis__);\n// This is a ponyfill, so...\n__globalThis__.fetch.ponyfill = true;\ndelete __globalThis__.fetch.polyfill;\n// Choose between native implementation (__global__) or custom implementation (__globalThis__)\nvar ctx = __global__.fetch ? __global__ : __globalThis__;\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\n;\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\n;\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\n;\nexports.Headers = ctx.Headers;\nexports.Request = ctx.Request;\nexports.Response = ctx.Response;\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCJtYXBwaW5ncyI6IkFBQUEsbUNBQW1DOztBQUNuQyxJQUFJQSxhQUNKLE9BQVFDLGVBQWUsZUFBZUEsY0FDckMsT0FBT0MsU0FBUyxlQUFlQSxRQUMvQixPQUFPQyxxQkFBTUEsS0FBSyxlQUFlQSxxQkFBTUE7QUFDeEMsMkVBQTJFO0FBQzNFLElBQUlDLGlCQUFpQjtJQUNyQixTQUFTQztRQUNULElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxZQUFZLEdBQUdQLFdBQVdPLFlBQVk7SUFDM0M7SUFDQUYsRUFBRUcsU0FBUyxHQUFHUixZQUFZLHNEQUFzRDtJQUNoRixPQUFPLElBQUlLO0FBQ1g7QUFDQSx1RUFBdUU7QUFDdkUsMENBQTBDO0FBQ3pDLFVBQVNKLFdBQVU7SUFFcEIsSUFBSVEsYUFBYSxTQUFXQyxRQUFPO1FBRWpDLElBQUlQLFVBQ0YsT0FBUUYsZ0JBQWUsZUFBZUEsZUFDckMsT0FBT0MsU0FBUyxlQUFlQSxRQUMvQixPQUFPQyxZQUFXLGVBQWVBO1FBRXBDLElBQUlRLFVBQVU7WUFDWkMsY0FBYyxxQkFBcUJUO1lBQ25DVSxVQUFVLFlBQVlWLFdBQVUsY0FBY1c7WUFDOUNDLE1BQ0UsZ0JBQWdCWixXQUNoQixVQUFVQSxXQUNWO2dCQUNFLElBQUk7b0JBQ0YsSUFBSWE7b0JBQ0osT0FBTztnQkFDVCxFQUFFLE9BQU9DLEdBQUc7b0JBQ1YsT0FBTztnQkFDVDtZQUNGO1lBQ0ZDLFVBQVUsY0FBY2Y7WUFDeEJnQixhQUFhLGlCQUFpQmhCO1FBQ2hDO1FBRUEsU0FBU2lCLFdBQVdDLEdBQUc7WUFDckIsT0FBT0EsT0FBT0MsU0FBU2QsU0FBUyxDQUFDZSxhQUFhLENBQUNGO1FBQ2pEO1FBRUEsSUFBSVYsUUFBUVEsV0FBVyxFQUFFO1lBQ3ZCLElBQUlLLGNBQWM7Z0JBQ2hCO2dCQUNBO2dCQUNBO2dC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TXVMLFFBQVEsR0FBRztRQUVqQixJQUFJLENBQUMxTCxRQUFPRyxLQUFLLEVBQUU7WUFDakJILFFBQU9HLEtBQUssR0FBR0E7WUFDZkgsUUFBTzRDLE9BQU8sR0FBR0E7WUFDakI1QyxRQUFPd0gsT0FBTyxHQUFHQTtZQUNqQnhILFFBQU9tSixRQUFRLEdBQUdBO1FBQ3BCO1FBRUE1SSxTQUFRcUMsT0FBTyxHQUFHQTtRQUNsQnJDLFNBQVFpSCxPQUFPLEdBQUdBO1FBQ2xCakgsU0FBUTRJLFFBQVEsR0FBR0E7UUFDbkI1SSxTQUFRSixLQUFLLEdBQUdBO1FBRWhCLE9BQU9JO0lBRVQsRUFBRyxDQUFDO0FBQ0osR0FBR047QUFDSCw0QkFBNEI7QUFDNUJBLGVBQWVFLEtBQUssQ0FBQ3dMLFFBQVEsR0FBRztBQUNoQyxPQUFPMUwsZUFBZUUsS0FBSyxDQUFDdUwsUUFBUTtBQUNwQyw4RkFBOEY7QUFDOUYsSUFBSUUsTUFBTS9MLFdBQVdNLEtBQUssR0FBR04sYUFBYUk7QUFDMUNNLFVBQVVxTCxJQUFJekwsS0FBSyxDQUFDLDZDQUE2Qzs7QUFDakVJLGtCQUFlLEdBQUdxTCxJQUFJekwsS0FBSyxDQUFDLG9EQUFvRDs7QUFDaEZJLGFBQWEsR0FBR3FMLElBQUl6TCxLQUFLLENBQUMsK0NBQStDOztBQUN6RUksZUFBZSxHQUFHcUwsSUFBSWhKLE9BQU87QUFDN0JyQyxlQUFlLEdBQUdxTCxJQUFJcEUsT0FBTztBQUM3QmpILGdCQUFnQixHQUFHcUwsSUFBSXpDLFFBQVE7QUFDL0IyQyxPQUFPdkwsT0FBTyxHQUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzP2ViZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2F2ZSBnbG9iYWwgb2JqZWN0IGluIGEgdmFyaWFibGVcbnZhciBfX2dsb2JhbF9fID1cbih0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbih0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbih0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpO1xuLy8gQ3JlYXRlIGFuIG9iamVjdCB0aGF0IGV4dGVuZHMgZnJvbSBfX2dsb2JhbF9fIHdpdGhvdXQgdGhlIGZldGNoIGZ1bmN0aW9uXG52YXIgX19nbG9iYWxUaGlzX18gPSAoZnVuY3Rpb24gKCkge1xuZnVuY3Rpb24gRigpIHtcbnRoaXMuZmV0Y2ggPSBmYWxzZTtcbnRoaXMuRE9NRXhjZXB0aW9uID0gX19nbG9iYWxfXy5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gX19nbG9iYWxfXzsgLy8gTmVlZGVkIGZvciBmZWF0dXJlIGRldGVjdGlvbiBvbiB3aGF0d2ctZmV0Y2gncyBjb2RlXG5yZXR1cm4gbmV3IEYoKTtcbn0pKCk7XG4vLyBXcmFwcyB3aGF0d2ctZmV0Y2ggd2l0aCBhIGZ1bmN0aW9uIHNjb3BlIHRvIGhpamFjayB0aGUgZ2xvYmFsIG9iamVjdFxuLy8gXCJnbG9iYWxUaGlzXCIgdGhhdCdzIGdvaW5nIHRvIGJlIHBhdGNoZWRcbihmdW5jdGlvbihnbG9iYWxUaGlzKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIGdsb2JhbCA9XG4gICAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKTtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGdsb2JhbCxcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZ2xvYmFsICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gZ2xvYmFsICYmXG4gICAgICAnQmxvYicgaW4gZ2xvYmFsICYmXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZ2xvYmFsLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdsb2JhbFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAvKlxuICAgICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAgICovXG4gICAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZDtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29uc3VtZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovO1xuICAgICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy87XG4gICAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcmJylcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgICAgLnNwbGl0KCdcXHInKVxuICAgICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICAgIH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dDtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZ2xvYmFsLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnbG9iYWwubG9jYXRpb24uaHJlZiA/IGdsb2JhbC5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXIgJiZcbiAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAmJlxuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLmluZGV4T2YoJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpICE9PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIWdsb2JhbC5mZXRjaCkge1xuICAgIGdsb2JhbC5mZXRjaCA9IGZldGNoO1xuICAgIGdsb2JhbC5IZWFkZXJzID0gSGVhZGVycztcbiAgICBnbG9iYWwuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgZ2xvYmFsLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIH1cblxuICBleHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBleHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBleHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIGV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSkoe30pO1xufSkoX19nbG9iYWxUaGlzX18pO1xuLy8gVGhpcyBpcyBhIHBvbnlmaWxsLCBzby4uLlxuX19nbG9iYWxUaGlzX18uZmV0Y2gucG9ueWZpbGwgPSB0cnVlO1xuZGVsZXRlIF9fZ2xvYmFsVGhpc19fLmZldGNoLnBvbHlmaWxsO1xuLy8gQ2hvb3NlIGJldHdlZW4gbmF0aXZlIGltcGxlbWVudGF0aW9uIChfX2dsb2JhbF9fKSBvciBjdXN0b20gaW1wbGVtZW50YXRpb24gKF9fZ2xvYmFsVGhpc19fKVxudmFyIGN0eCA9IF9fZ2xvYmFsX18uZmV0Y2ggPyBfX2dsb2JhbF9fIDogX19nbG9iYWxUaGlzX187XG5leHBvcnRzID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5kZWZhdWx0ID0gY3R4LmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQge2ZldGNofSBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuSGVhZGVycyA9IGN0eC5IZWFkZXJzXG5leHBvcnRzLlJlcXVlc3QgPSBjdHguUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IGN0eC5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iXSwibmFtZXMiOlsiX19nbG9iYWxfXyIsImdsb2JhbFRoaXMiLCJzZWxmIiwiZ2xvYmFsIiwiX19nbG9iYWxUaGlzX18iLCJGIiwiZmV0Y2giLCJET01FeGNlcHRpb24iLCJwcm90b3R5cGUiLCJpcnJlbGV2YW50IiwiZXhwb3J0cyIsInN1cHBvcnQiLCJzZWFyY2hQYXJhbXMiLCJpdGVyYWJsZSIsIlN5bWJvbCIsImJsb2IiLCJCbG9iIiwiZSIsImZvcm1EYXRhIiwiYXJyYXlCdWZmZXIiLCJpc0RhdGFWaWV3Iiwib2JqIiwiRGF0YVZpZXciLCJpc1Byb3RvdHlwZU9mIiwidmlld0NsYXNzZXMiLCJpc0FycmF5QnVmZmVyVmlldyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaW5kZXhPZiIsIk9iamVjdCIsInRvU3RyaW5nIiwiY2FsbCIsIm5vcm1hbGl6ZU5hbWUiLCJuYW1lIiwiU3RyaW5nIiwidGVzdCIsIlR5cGVFcnJvciIsInRvTG93ZXJDYXNlIiwibm9ybWFsaXplVmFsdWUiLCJ2YWx1ZSIsIml0ZXJhdG9yRm9yIiwiaXRlbXMiLCJpdGVyYXRvciIsIm5leHQiLCJzaGlmdCIsImRvbmUiLCJ1bmRlZmluZWQiLCJIZWFkZXJzIiwiaGVhZGVycyIsIm1hcCIsImZvckVhY2giLCJhcHBlbmQiLCJBcnJheSIsImlzQXJyYXkiLCJoZWFkZXIiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2xkVmFsdWUiLCJnZXQiLCJoYXMiLCJoYXNPd25Qcm9wZXJ0eSIsInNldCIsImNhbGxiYWNrIiwidGhpc0FyZyIsImtleXMiLCJwdXNoIiwidmFsdWVzIiwiZW50cmllcyIsImNvbnN1bWVkIiwiYm9keSIsImJvZHlVc2VkIiwiUHJvbWlzZSIsInJlamVjdCIsImZpbGVSZWFkZXJSZWFkeSIsInJlYWRlciIsInJlc29sdmUiLCJvbmxvYWQiLCJyZXN1bHQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQmxvYkFzQXJyYXlCdWZmZXIiLCJGaWxlUmVhZGVyIiwicHJvbWlzZSIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEJsb2JBc1RleHQiLCJyZWFkQXNUZXh0IiwicmVhZEFycmF5QnVmZmVyQXNUZXh0IiwiYnVmIiwidmlldyIsIlVpbnQ4QXJyYXkiLCJjaGFycyIsImxlbmd0aCIsImkiLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiYnVmZmVyQ2xvbmUiLCJzbGljZSIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJCb2R5IiwiX2luaXRCb2R5IiwiX2JvZHlJbml0IiwiX2JvZHlUZXh0IiwiX2JvZHlCbG9iIiwiRm9ybURhdGEiLCJfYm9keUZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2JvZHlBcnJheUJ1ZmZlciIsInR5cGUiLCJyZWplY3RlZCIsIkVycm9yIiwiaXNDb25zdW1lZCIsImJ5dGVPZmZzZXQiLCJ0aGVuIiwidGV4dCIsImRlY29kZSIsImpzb24iLCJKU09OIiwicGFyc2UiLCJtZXRob2RzIiwibm9ybWFsaXplTWV0aG9kIiwibWV0aG9kIiwidXBjYXNlZCIsInRvVXBwZXJDYXNlIiwiUmVxdWVzdCIsImlucHV0Iiwib3B0aW9ucyIsInVybCIsImNyZWRlbnRpYWxzIiwibW9kZSIsInNpZ25hbCIsInJlZmVycmVyIiwiY2FjaGUiLCJyZVBhcmFtU2VhcmNoIiwicmVwbGFjZSIsIkRhdGUiLCJnZXRUaW1lIiwicmVRdWVyeVN0cmluZyIsImNsb25lIiwiZm9ybSIsInRyaW0iLCJzcGxpdCIsImJ5dGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInByZVByb2Nlc3NlZEhlYWRlcnMiLCJzdWJzdHIiLCJsaW5lIiwicGFydHMiLCJrZXkiLCJSZXNwb25zZSIsImJvZHlJbml0Iiwic3RhdHVzIiwib2siLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJyZWRpcmVjdFN0YXR1c2VzIiwicmVkaXJlY3QiLCJSYW5nZUVycm9yIiwibG9jYXRpb24iLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJyZXF1ZXN0IiwiYWJvcnRlZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRYaHIiLCJhYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VUZXh0Iiwic2V0VGltZW91dCIsIm9udGltZW91dCIsIm9uYWJvcnQiLCJmaXhVcmwiLCJocmVmIiwib3BlbiIsIndpdGhDcmVkZW50aWFscyIsInJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZW5kIiwicG9seWZpbGwiLCJwb255ZmlsbCIsImN0eCIsImRlZmF1bHQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/cross-fetch/dist/browser-ponyfill.js\n"));

/***/ })

}]);